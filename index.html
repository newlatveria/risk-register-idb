<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Risk Register - Main View</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2 {
            color: #0056b3;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        /* --- TOP ACTIONS (New Risk & Management) --- */
        .top-actions {
            display: flex;
            gap: 10px;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            margin-bottom: 10px;
        }
        
        /* --- FILTER CONTROLS --- */
        .filter-actions {
            display: flex;
            flex-wrap: wrap; 
            gap: 20px;
            padding: 10px 0;
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        .filter-actions div {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .filter-actions label {
            font-weight: bold;
            color: #555;
        }

        /* --- DATA MANAGEMENT SECTION --- */
        .data-management-section {
            padding: 20px;
            margin-top: 20px;
            border-top: 2px solid #007bff;
            background-color: #e9f5ff;
            border-radius: 8px;
        }
        .data-management-section h2 {
            margin-top: 0;
            color: #0056b3;
            border-bottom: 1px solid #007bff;
            padding-bottom: 5px;
        }
        
        /* New File Info Style */
        .file-info {
            font-weight: bold;
            color: #555;
            margin-bottom: 15px;
            padding: 8px 12px;
            background-color: #fff;
            border-left: 4px solid #28a745;
            border-radius: 2px;
            display: inline-block;
        }

        .file-controls-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }
        .file-controls-group > div {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .file-controls-group .load-controls, .file-controls-group .save-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* --- BUTTONS & INPUTS --- */
        button, select {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        select {
            background-color: #f8f9fa;
            color: #333;
            border: 1px solid #ccc;
            padding: 8px 10px;
        }
        input[type="file"] {
            padding: 5px;
            border: 1px solid #ccc;
            background-color: #eee;
            border-radius: 4px;
            cursor: pointer;
        }
        input.inline-edit, select.inline-edit {
            padding: 4px;
            box-sizing: border-box;
            width: 100%;
            height: 100%;
            border: 1px solid #007bff;
            background-color: #fff;
        }
        
        /* Specific button styling */
        #addNewRiskButton {
            background-color: #28a745;
        }
        #addNewRiskButton:hover {
            background-color: #1e7e34;
        }
        #manageDataButton {
            background-color: #d9534f;
        }
        #manageDataButton:hover {
            background-color: #c9302c;
        }
        /* Load from file (user input) */
        #loadDataButton {
            background-color: #5cb85c;
            position: relative; 
            min-width: 120px; 
        }
        #loadDataButton:hover {
            background-color: #4cae4c;
        }
        /* Load Default File */
        #loadDefaultFileButton {
            background-color: #ff9800;
            position: relative;
            min-width: 120px;
        }
        #loadDefaultFileButton:hover {
             background-color: #e68900;
        }

        #saveJsonButton {
            background-color: #007bff;
        }
        #saveJsonButton:hover {
            background-color: #0056b3;
        }
        #saveCsvButton {
            background-color: #f0ad4e;
        }
        #saveCsvButton:hover {
            background-color: #ec971f;
        }

        /* --- Loading Indicator CSS --- */
        .loading-indicator {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #ffffff; 
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: none;
            margin-left: 5px;
        }

        /* Show the spinner when loading is active */
        #loadDataButton.loading .button-text, #loadDefaultFileButton.loading .button-text {
            visibility: hidden;
            display: block;
        }
        #loadDataButton.loading .loading-indicator, #loadDefaultFileButton.loading .loading-indicator {
            display: inline-block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- SCROLL CONTAINER & TABLE STYLES --- */
        .table-scroll-container {
            max-height: 480px; 
            overflow-y: scroll;
            overflow-x: auto;
            margin-top: 20px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            white-space: nowrap;
        }
        table thead th {
            background-color: #007bff;
            color: white;
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        table tbody td {
            padding: 0; 
            border: 1px solid #ddd;
            vertical-align: top;
            height: 40px; 
        }
        table tbody td > div {
            padding: 10px;
            height: 100%;
            box-sizing: border-box;
        }
        table tbody tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        table tbody tr:hover {
            background-color: #e9e9e9;
        }
        .edit-btn {
            background-color: #ffc107;
            color: #333;
            margin-right: 5px;
            padding: 6px 10px;
            font-size: 0.9em;
            margin-top: 0;
        }
        .edit-btn:hover {
            background-color: #e0a800;
        }
        /* Risk Rating Classes */
        .risk-rating-low { background-color: #d4edda; color: #155724; }
        .risk-rating-medium { background-color: #fff3cd; color: #856404; }
        .risk-rating-high { background-color: #f8d7da; color: #721c24; }
        .risk-rating-critical { background-color: #6c757d; color: white; }
        /* Sticky Columns CSS */
        #riskTable th:first-child, #riskTable td:first-child,
        #riskTable th:last-child, #riskTable td:last-child {
            position: sticky;
            z-index: 11;
        }
        #riskTable th:first-child, #riskTable td:first-child { left: 0; }
        #riskTable th:last-child, #riskTable td:last-child { right: 0; }
        #riskTable th:first-child, #riskTable th:last-child { background-color: #007bff; }
        #riskTable tbody tr:nth-child(even) td:first-child, #riskTable tbody tr:nth-child(even) td:last-child { background-color: #f2f2f2; }
        #riskTable tbody tr:nth-child(odd) td:first-child, #riskTable tbody tr:nth-child(odd) td:last-child { background-color: #fff; }

        /* Review Date Color Coding */
        .due-soon { background-color: #ffeb3b; } 
        .due-next-week { background-color: #ffc107; } 
        .overdue { background-color: #f44336; color: white; } 
    </style>
</head>
<body>
    <div class="container">
        <h1>Risk Register</h1>

        <div class="top-actions">
            <button id="addNewRiskButton">‚ûï Add New Risk</button>
            <button onclick="window.location.href='risk_map.html'" style="background-color: #6610f2;">üï∏Ô∏è View Risk Map</button>
            <button onclick="window.location.href='all_risks.html'" style="background-color: #17a2b8;">üìÑ View Full Report</button>
            <button id="manageDataButton" title="Access administrative controls for data deletion and maintenance.">
                Manage Data (Advanced)
            </button>
        </div>

        <div class="filter-actions">
            <div>
                <label for="statusFilter">Status:</label>
                <select id="statusFilter" onchange="filterTable()">
                    <option value="">All</option>
                    <option value="Open">Open</option>
                    <option value="In Progress">In Progress</option>
                    <option value="Closed">Closed</option>
                    <option value="On Hold">On Hold</option>
                </select>
            </div>
            <div>
                <label for="ratingFilter">Residual Rating:</label>
                <select id="ratingFilter" onchange="filterTable()">
                    <option value="">All Ratings</option>
                    <option value="Critical">Critical</option>
                    <option value="High">High</option>
                    <option value="Medium">Medium</option>
                    <option value="Low">Low</option>
                </select>
            </div>
            <div>
                <label for="ownerFilter">Risk Owner:</label>
                <select id="ownerFilter" onchange="filterTable()">
                    <option value="">All Owners</option>
                </select>
            </div>
            <div>
                <label for="reviewDateFilter">Review Date:</label>
                <select id="reviewDateFilter" onchange="filterTable()">
                    <option value="">Any Time</option>
                    <option value="Overdue">Overdue</option>
                    <option value="DueNextWeek">Due in 0-7 Days</option>
                    <option value="DueSoon">Due in 7-28 Days</option> 
                </select>
            </div>
        </div>

        <div class="table-scroll-container">
            <table id="riskTable">
                <thead>
                    <tr>
                        <th class="sticky-header">Risk Number</th>
                        <th class="sticky-header">Risk Item</th>
                        <th class="sticky-header" data-key="riskOwner">Risk Owner</th>
                        <th class="sticky-header">Rating (Residual)</th>
                        <th class="sticky-header" data-key="riskStatus">Risk Status</th>
                        <th class="sticky-header" data-key="reviewDate">Review Date</th>
                        
                        <th class="sticky-header">Age (Days)</th>
                        <th class="sticky-header">Date Raised</th>
                        <th class="sticky-header">Raised By</th>
                        <th class="sticky-header">Impact Statement</th>
                        <th class="sticky-header">Controls/Mitigations</th>
                        <th class="sticky-header">Prob (Initial)</th>
                        <th class="sticky-header">Impact (Initial)</th>
                        <th class="sticky-header">Score (Initial)</th>
                        <th class="sticky-header">Rating (Initial)</th>
                        <th class="sticky-header">Prob (Residual)</th>
                        <th class="sticky-header">Impact (Residual)</th>
                        <th class="sticky-header">Score (Residual)</th>
                        <th class="sticky-header" data-key="actionsText">Actions Text (Current)</th>
                        <th class="sticky-header">Notes / History</th>
                        
                        <th class="sticky-header">Impacted Area</th>
                        <th class="sticky-header">Risk Category</th>
                        <th class="sticky-header">Related Laws/Regs</th>
                        <th class="sticky-header">Non-Compliance Impact</th>
                        <th class="sticky-header">Outcome Definition</th>
                        <th class="sticky-header" style="background-color: #8c72a8;">Source Department</th>
                        <th class="sticky-header" style="background-color: #8c72a8;">Source Last Review Date</th>
                        <th class="sticky-header" style="background-color: #8c72a8;">Source Due Date</th>
                        
                        <th class="sticky-header">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    </tbody>
            </table>
        </div>
        
        <div class="data-management-section">
            <h2>Data Import / Export</h2>
            
            <p id="lastFileDisplay" class="file-info">Last Imported Source: None</p>

            <p>Loading a file will **replace all existing data** in the register.</p>
            
            <div class="file-controls-group">
                <div class="load-controls">
                    <input type="file" id="fileInput" accept=".json, .csv" title="Select either a JSON or CSV file to load data.">
                    <button id="loadDataButton" title="Load data from the selected file (JSON or CSV).">
                        <span class="button-text">Load Data (File)</span>
                        <div class="loading-indicator"></div>
                    </button>
                    <button id="loadDefaultFileButton" title="Load the default risk register file from /data/default_risks.json.">
                        <span class="button-text">Load Default</span>
                        <div class="loading-indicator"></div>
                    </button>
                </div>
            </div>
            
            <div class="file-controls-group">
                <div class="save-controls">
                    <button id="saveJsonButton" title="Download the current risk register data as a JSON file.">Save as JSON</button>
                    <button id="saveCsvButton" title="Download the current risk register data as a CSV file (Full Format).">Save as CSV</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        
        // =========================================================
        // === MODULE 1: IndexedDB Configuration and CRUD Wrappers ===
        // =========================================================
        const DB_NAME = 'RiskRegisterDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'risks';
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                if (db) {
                    resolve(db);
                    return;
                }
                
                if (!window.indexedDB) {
                    reject(new Error("IndexedDB not supported."));
                    return;
                }

                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    console.error("[IDB] Database error:", event.target.error);
                    reject(event.target.error);
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("[IDB] Database opened successfully.");
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'riskNumber' });
                        objectStore.createIndex('riskOwner', 'riskOwner', { unique: false });
                        console.log("[IDB] Object store created/upgraded.");
                    }
                };
            });
        }

        async function getAllRisksDB() {
            const dbInstance = await initDB();
            return new Promise((resolve, reject) => {
                const transaction = dbInstance.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();

                request.onerror = (event) => reject(event.target.error);
                request.onsuccess = (event) => resolve(event.target.result);
            });
        }
        
        async function getRiskByNumberDB(riskNumber) {
            const dbInstance = await initDB();
            return new Promise((resolve, reject) => {
                const transaction = dbInstance.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(riskNumber);

                request.onerror = (event) => reject(event.target.error);
                request.onsuccess = (event) => resolve(event.target.result);
            });
        }

        async function updateRiskInDB(risk) {
            const dbInstance = await initDB();
            return new Promise((resolve, reject) => {
                const transaction = dbInstance.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(risk); 

                request.onerror = (event) => reject(event.target.error);
                request.onsuccess = () => resolve();
            });
        }
        
        async function bulkPutRisksDB(risks) {
            const dbInstance = await initDB();
            return new Promise((resolve, reject) => {
                const transaction = dbInstance.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                // Clear existing risks first if this is an import
                const clearRequest = store.clear();
                
                clearRequest.onerror = (event) => {
                    console.error("[IDB CLEAR] Error clearing store:", event.target.error);
                    reject(event.target.error);
                };
                
                clearRequest.onsuccess = () => {
                    risks.forEach(risk => {
                        store.put(risk);
                    });
                    transaction.oncomplete = () => {
                        console.log("[IDB PUT] Bulk insert complete.");
                        resolve();
                    };
                    transaction.onerror = (event) => {
                        console.error("[IDB PUT] Error during bulk insert:", event.target.error);
                        reject(event.target.error);
                    };
                };
            });
        }

        // ==================================================
        // === MODULE 2: Global Variables and Configuration ===
        // ==================================================
        const riskTableBody = document.querySelector('#riskTable tbody');
        const fileInput = document.getElementById('fileInput'); 
        const loadDataButton = document.getElementById('loadDataButton'); 
        const loadDefaultFileButton = document.getElementById('loadDefaultFileButton'); 
        const saveCsvButton = document.getElementById('saveCsvButton');
        const saveJsonButton = document.getElementById('saveJsonButton');
        const addNewRiskButton = document.getElementById('addNewRiskButton');
        const manageDataButton = document.getElementById('manageDataButton');
        
        // NEW: Element for displaying last imported file name
        const lastFileDisplay = document.getElementById('lastFileDisplay');

        // FILTER ELEMENTS
        const statusFilter = document.getElementById('statusFilter');
        const ratingFilter = document.getElementById('ratingFilter');
        const ownerFilter = document.getElementById('ownerFilter');
        const reviewDateFilter = document.getElementById('reviewDateFilter');
        
        // CONFIGURATION
        const DEFAULT_RISK_FILE_PATH = 'data/default_risks.json'; 
        let risks = []; 
        let riskOwners = []; 

        // --- Configuration ---
        const RISK_STATUSES = ["Open", "In Progress", "Closed", "On Hold"];

        // CSV HEADERS AND MAPS (Used for export and import mapping)
        const csvHeaders = [
            "Risk Number", "Date Raised", "Raised By", "Risk Item", "Risk Issue", "Impact Statement",
            "Impacted Area", "Risk Category", "Related Laws/Regulations", "Non-Compliance Impact",
            "Probability (Initial)", "Impact (Initial)",
            "Initial Risk Score", "Initial Risk Rating", "Outcome Definition", "Risk Owner",
            "Controls/Mitigations", "Probability (Residual)", "Impact (Residual)",
            "Residual Risk Score", "Residual Risk Rating", 
            "Actions Text (Current)", "Notes / History", 
            "Risk Status", "Review Date", "Age (Days)",
            "Source Department", "Source Last Review Date", "Source Due Date"
        ];
        const riskKeyToCsvHeaderMap = {
            riskNumber: "Risk Number", dateRaised: "Date Raised", raisedBy: "Raised By", riskItem: "Risk Item", 
            riskIssue: "Risk Issue", impactStatement: "Impact Statement", impactedArea: "Impacted Area", 
            riskCategory: "Risk Category", relatedLaws: "Related Laws/Regulations", nonComplianceImpact: "Non-Compliance Impact", 
            probabilityInitial: "Probability (Initial)", impactInitial: "Impact (Initial)", riskScoreInitial: "Initial Risk Score", 
            riskRatingInitial: "Initial Risk Rating", outcomeDefinition: "Outcome Definition", riskOwner: "Risk Owner", 
            controlsMitigations: "Controls/Mitigations", probabilityResidual: "Probability (Residual)", impactResidual: "Impact (Residual)", 
            riskScoreResidual: "Residual Risk Score", riskRatingResidual: "Residual Risk Rating", 
            actionsText: "Actions Text (Current)", notesHistory: "Notes / History", 
            riskStatus: "Risk Status", reviewDate: "Review Date",
            sourceDepartment: "Source Department", sourceLastReviewDate: "Source Last Review Date", sourceDueDate: "Source Due Date"
        };
        const csvHeaderToRiskKeyMap = Object.fromEntries(
            Object.entries(riskKeyToCsvHeaderMap).map(([key, value]) => [value, key])
        );

        // ===========================================
        // === MODULE 3: Core Utility Functions (Date, Math, Risk) ===
        // ===========================================
        
        function parseUKDate(dateString) {
            if (!dateString) return null;
            dateString = String(dateString).trim();

            let date = new Date(dateString);
            if (!isNaN(date.getTime()) && date.getFullYear() > 1900) {
                return date;
            }

            const parts = dateString.match(/^(\d{1,2})[/-](\d{1,2})[/-](\d{4})$/);
            if (parts) {
                date = new Date(parts[3], parts[2] - 1, parts[1]); 
                if (!isNaN(date.getTime()) && date.getFullYear() > 1900) {
                    return date;
                }
            }
            
            return null;
        }

        function getFormattedDate(dateValue) {
            if (!dateValue) return '';
            
            let date;
            if (dateValue instanceof Date) {
                date = dateValue;
            } else {
                date = parseUKDate(dateValue);
            }

            if (!date || isNaN(date.getTime())) {
                return '';
            }

            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            
            return `${year}-${month}-${day}`;
        }
        
        function getRiskRatingClass(rating) {
            switch (rating) {
                case 'Low': return 'risk-rating-low';
                case 'Medium': return 'risk-rating-medium';
                case 'High': return 'risk-rating-high';
                case 'Critical': return 'risk-rating-critical';
                default: return '';
            }
        }

        function calculateDateMetrics(dateRaised, reviewDate) {
            const today = new Date();
            today.setHours(0, 0, 0, 0); 

            let ageDays = '';
            if (dateRaised) {
                const raised = new Date(dateRaised);
                const diffTime = today - raised;
                ageDays = Math.max(0, Math.ceil(diffTime / (1000 * 60 * 60 * 24)));
            }
            
            let reviewDaysDiff = Infinity;
            let reviewClass = ''; 
            if (reviewDate) {
                const review = new Date(reviewDate);
                review.setHours(0, 0, 0, 0); 
                
                const diffTime = review - today;
                reviewDaysDiff = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                
                if (reviewDaysDiff < 0) {
                    reviewClass = 'overdue';
                } else if (reviewDaysDiff <= 7) {
                    reviewClass = 'due-next-week';
                } else if (reviewDaysDiff <= 28) { 
                    reviewClass = 'due-soon';
                }
            }
            
            return { ageDays, reviewDaysDiff, reviewClass };
        }

        function getRiskRating(score) {
            if (score <= 5) return 'Low';
            if (score <= 10) return 'Medium';
            if (score <= 15) return 'High';
            return 'Critical';
        }

        function safeParseInt(value) {
            const num = parseInt(value, 10);
            return isNaN(num) ? '' : num;
        }

        function calculateRiskScore(probability, impact) {
            const p = parseInt(probability);
            const i = parseInt(impact);
            return (p && i && !isNaN(p) && !isNaN(i)) ? p * i : '';
        }

        // ============================================
        // === MODULE 4: Data Load, Filter, and Render ===
        // ============================================

        function updateLastFileDisplay() {
            const lastFile = localStorage.getItem('lastImportedFile') || 'None';
            lastFileDisplay.innerHTML = `Last Imported Source: <strong>${lastFile}</strong>`;
        }

        function applyDefaultReviewDateFilter() {
            const reviewFilterValue = localStorage.getItem('reviewDateFilter') || '';
            
            if (!['Overdue', 'DueNextWeek', 'DueSoon'].includes(reviewFilterValue)) {
                reviewDateFilter.value = 'Overdue'; 
                localStorage.setItem('reviewDateFilter', 'Overdue');
                console.log("[FILTER] Applying default filter: Overdue.");
            } else {
                reviewDateFilter.value = reviewFilterValue;
                console.log(`[FILTER] Retaining existing filter: ${reviewFilterValue}.`);
            }
            
            renderRisks();
        }

        async function loadRisks(buttonElement = loadDataButton) {
            buttonElement.classList.add('loading');
            riskTableBody.innerHTML = '<tr><td colspan="29" style="text-align:center; padding: 20px;">Loading data... Please wait.</td></tr>';
            
            try {
                await initDB(); 
                
                const storedRisks = await getAllRisksDB();
                risks = storedRisks;

                console.log(`[IDB LOAD] Data loaded from IndexedDB. Total risks: ${risks.length}`);
                
                risks.forEach(risk => {
                    if (risk.actions) {
                        risk.actionsText = risk.actions; 
                        risk.notesHistory = '';
                        delete risk.actions;
                    }
                    if (risk.actionsText === undefined) risk.actionsText = '';
                    if (risk.notesHistory === undefined) risk.notesHistory = '';
                    if (risk.relatedLaws === undefined) risk.relatedLaws = '';
                });
                
                updateRiskOwnersList();
                populateOwnerFilter(); 
                
                applyDefaultReviewDateFilter(); 
                updateLastFileDisplay(); // Update the filename indicator
                
            } catch (error) {
                console.error('[IDB LOAD] Failed to load risks:', error);
                alert('Failed to load risk data from the database. See console for details.');
            } finally {
                buttonElement.classList.remove('loading');
            }
        }
        
        function getNextRiskNumber(currentRisks) {
            if (currentRisks.length === 0) return 1;
            const maxNumber = currentRisks.reduce((max, risk) => {
                const num = parseInt(risk.riskNumber, 10);
                return isNaN(num) ? max : Math.max(max, num);
            }, 0);
            return maxNumber + 1;
        }

        async function ensureUniqueRiskNumbers(loadedRisks) {
            if (!Array.isArray(loadedRisks) || loadedRisks.length === 0) return loadedRisks;
            
            console.log('[DUPE CHECK] Starting unique number enforcement.');
            const seenNumbers = new Set(risks.map(r => String(r.riskNumber))); 
            let nextUniqueNumber = getNextRiskNumber(risks); 
            let duplicatesFound = 0;

            for (const risk of loadedRisks) {
                let riskNum = String(risk.riskNumber).trim();
                
                if (!riskNum || isNaN(parseInt(riskNum, 10)) || seenNumbers.has(riskNum)) {
                    riskNum = String(nextUniqueNumber);
                    duplicatesFound++;
                }
                
                if (parseInt(riskNum, 10) >= nextUniqueNumber) {
                    nextUniqueNumber = parseInt(riskNum, 10) + 1;
                }

                risk.riskNumber = riskNum;
                seenNumbers.add(riskNum);
                
                if (risk.actions) {
                    risk.actionsText = risk.actions;
                    risk.notesHistory = '';
                    delete risk.actions;
                }
            }
            
            if (duplicatesFound > 0) {
                console.warn(`NOTICE: ${duplicatesFound} duplicate or invalid Risk Numbers were corrected/assigned.`);
            }
            
            console.log(`[DUPE CHECK] Finished. ${duplicatesFound} risks corrected.`);
            return loadedRisks;
        }

        function updateRiskOwnersList() {
             const owners = [...new Set(risks.map(r => r.riskOwner).filter(owner => owner))].sort();
             riskOwners = owners; 
        }

        function populateOwnerFilter() {
            const owners = riskOwners; 
            const currentOwner = ownerFilter.value; 
            ownerFilter.innerHTML = '<option value="">All Owners</option>';
            
            owners.forEach(owner => {
                const option = document.createElement('option');
                option.value = owner;
                option.textContent = owner;
                ownerFilter.appendChild(option);
            });

            if (owners.includes(currentOwner)) {
                ownerFilter.value = currentOwner;
            }
        }

        function filterTable() {
            localStorage.setItem('reviewDateFilter', reviewDateFilter.value);
            renderRisks(); 
        }

        function renderRisks() {
            riskTableBody.innerHTML = '';
            
            if (risks.length === 0) {
                 riskTableBody.innerHTML = '<tr><td colspan="29" style="text-align:center; padding: 20px;">No risks found. Import data or add a new risk.</td></tr>';
                 return;
            }

            const selectedStatus = statusFilter.value;
            const selectedRating = ratingFilter.value;
            const selectedOwner = ownerFilter.value;
            const selectedReview = reviewDateFilter.value;

            const filteredRisks = risks.filter(risk => {
                const metrics = calculateDateMetrics(risk.dateRaised, risk.reviewDate);
                
                const statusMatch = !selectedStatus || risk.riskStatus === selectedStatus;
                const ratingMatch = !selectedRating || risk.riskRatingResidual === selectedRating;
                const ownerMatch = !selectedOwner || (risk.riskOwner || '') === selectedOwner; 
                
                let reviewMatch = true;
                if (selectedReview === 'Overdue') {
                    reviewMatch = metrics.reviewDaysDiff < 0;
                } else if (selectedReview === 'DueSoon') {
                    reviewMatch = metrics.reviewDaysDiff > 7 && metrics.reviewDaysDiff <= 28;
                } else if (selectedReview === 'DueNextWeek') {
                    reviewMatch = metrics.reviewDaysDiff >= 0 && metrics.reviewDaysDiff <= 7;
                }

                return statusMatch && ratingMatch && ownerMatch && reviewMatch;
            });
            
            console.log(`[RENDER] Rendering ${filteredRisks.length} risks.`);

            filteredRisks.forEach((risk) => {
                const riskNumber = risk.riskNumber; 
                const row = riskTableBody.insertRow();
                
                const metrics = calculateDateMetrics(risk.dateRaised, risk.reviewDate);

                const createDisplayCell = (value, key) => {
                    const cell = row.insertCell();
                    cell.setAttribute('data-risk-number', riskNumber); 
                    cell.setAttribute('data-key', key);
                    
                    const div = document.createElement('div');
                    div.textContent = value;
                    
                    if (key === 'reviewDate') {
                        div.className = metrics.reviewClass;
                    }

                    cell.appendChild(div);
                    return cell;
                };

                row.insertCell().innerHTML = `<div>${risk.riskNumber}</div>`;
                row.insertCell().innerHTML = `<div>${risk.riskItem}</div>`;
                createDisplayCell(risk.riskOwner, 'riskOwner').ondblclick = handleInlineEdit;
                row.insertCell().innerHTML = `<div><span class="${getRiskRatingClass(risk.riskRatingResidual)}">${risk.riskRatingResidual}</span></div>`;
                createDisplayCell(risk.riskStatus, 'riskStatus').ondblclick = handleInlineEdit;
                createDisplayCell(risk.reviewDate, 'reviewDate').ondblclick = handleInlineEdit;
                
                row.insertCell().innerHTML = `<div>${metrics.ageDays}</div>`;
                row.insertCell().innerHTML = `<div>${risk.dateRaised}</div>`;
                row.insertCell().innerHTML = `<div>${risk.raisedBy}</div>`;
                row.insertCell().innerHTML = `<div>${risk.impactStatement}</div>`;
                row.insertCell().innerHTML = `<div>${risk.controlsMitigations}</div>`;
                row.insertCell().innerHTML = `<div>${risk.probabilityInitial}</div>`;
                row.insertCell().innerHTML = `<div>${risk.impactInitial}</div>`;
                row.insertCell().innerHTML = `<div>${risk.riskScoreInitial}</div>`;
                row.insertCell().innerHTML = `<div><span class="${getRiskRatingClass(risk.riskRatingInitial)}">${risk.riskRatingInitial}</span></div>`;
                row.insertCell().innerHTML = `<div>${risk.probabilityResidual}</div>`;
                row.insertCell().innerHTML = `<div>${risk.impactResidual}</div>`;
                row.insertCell().innerHTML = `<div>${risk.riskScoreResidual}</div>`;
                
                createDisplayCell(risk.actionsText, 'actionsText').ondblclick = handleInlineEdit;
                row.insertCell().innerHTML = `<div>${risk.notesHistory}</div>`;

                row.insertCell().innerHTML = `<div>${risk.impactedArea}</div>`;
                row.insertCell().innerHTML = `<div>${risk.riskCategory}</div>`;
                row.insertCell().innerHTML = `<div>${risk.relatedLaws}</div>`;
                row.insertCell().innerHTML = `<div>${risk.nonComplianceImpact}</div>`;
                row.insertCell().innerHTML = `<div>${risk.outcomeDefinition}</div>`;
                row.insertCell().innerHTML = `<div>${risk.sourceDepartment}</div>`;
                row.insertCell().innerHTML = `<div>${risk.sourceLastReviewDate}</div>`;
                row.insertCell().innerHTML = `<div>${risk.sourceDueDate}</div>`;

                const actionCell = row.insertCell();
                const editButton = document.createElement('button');
                editButton.textContent = 'Edit';
                editButton.className = 'edit-btn';
                editButton.onclick = () => window.location.href = `risk_form.html?id=${riskNumber}`; 
                actionCell.appendChild(editButton);
            });
        }

        // ==================================
        // === MODULE 5: Inline Editing Logic ===
        // ==================================
        async function handleInlineEdit(event) {
            const cell = event.currentTarget;
            if (cell.querySelector('input') || cell.querySelector('select')) return;

            const riskNumber = cell.getAttribute('data-risk-number');
            const key = cell.getAttribute('data-key');
            
            const risk = await getRiskByNumberDB(riskNumber);
            if (!risk) {
                console.error(`Risk #${riskNumber} not found.`);
                await loadRisks();
                return;
            }

            const currentValue = risk[key] || '';
            
            const originalDiv = cell.querySelector('div');
            originalDiv.style.display = 'none';

            let editor;

            if (key === 'riskStatus') {
                editor = document.createElement('select');
                RISK_STATUSES.forEach(status => {
                    const option = document.createElement('option');
                    option.value = status;
                    option.textContent = status;
                    if (status === currentValue) option.selected = true;
                    editor.appendChild(option);
                });
            } else if (key === 'riskOwner') {
                editor = document.createElement('select');
                
                const currentOwners = [...riskOwners];
                if (currentValue && !currentOwners.includes(currentValue)) {
                    currentOwners.push(currentValue);
                    currentOwners.sort();
                }
                
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- Select Owner --';
                editor.appendChild(defaultOption);

                currentOwners.forEach(owner => {
                    const option = document.createElement('option');
                    option.value = owner;
                    option.textContent = owner;
                    if (owner === currentValue) option.selected = true;
                    editor.appendChild(option);
                });
            } else if (key === 'reviewDate') {
                editor = document.createElement('input');
                editor.type = 'date';
                editor.value = currentValue;
            } else if (key === 'actionsText') { 
                editor = document.createElement('input');
                editor.type = 'text';
                editor.value = currentValue;
            } else {
                return; 
            }
            
            editor.className = 'inline-edit';
            editor.focus();
            cell.appendChild(editor);

            const saveEdit = async (newValue) => {
                if (!cell.contains(editor)) return; 

                if (String(newValue) !== String(currentValue)) {
                    risk[key] = (key.includes('Date')) ? getFormattedDate(newValue) : newValue;
                    
                    try {
                        await updateRiskInDB(risk);
                        console.log(`[IDB] Updated risk #${riskNumber} field: ${key}`);
                        
                        await loadRisks(); 
                        
                        if (key === 'riskOwner') {
                            updateRiskOwnersList();
                            populateOwnerFilter();
                        }
                    } catch (error) {
                        console.error(`[IDB] Failed to save inline edit for risk #${riskNumber}:`, error);
                        alert(`Failed to save changes. Risk #${riskNumber} was not updated.`);
                    }
                } else {
                    originalDiv.style.display = '';
                }
                if (cell.contains(editor)) {
                    cell.removeChild(editor);
                }
            };

            editor.addEventListener('change', (e) => saveEdit(e.target.value));
            
            editor.addEventListener('blur', (e) => {
                setTimeout(() => {
                    saveEdit(e.target.value);
                }, 50);
            });
            
            editor.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveEdit(e.target.value);
                }
            });
        }


        // ========================================
        // === MODULE 6: File I/O (Download, JSON Load) ===
        // ========================================

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: `${mimeType};charset=utf-8;` });
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                console.log(`[DOWNLOAD] File saved: ${filename}`);
            } else {
                alert('Your browser does not support downloading files directly.');
            }
        }

        async function loadJson(jsonText) {
            try {
                const loadedRisks = JSON.parse(jsonText);
                if (!Array.isArray(loadedRisks)) {
                    throw new Error("JSON file does not contain a risk array.");
                }
                
                let processedRisks = await ensureUniqueRiskNumbers(loadedRisks); 

                const validRisks = processedRisks.filter(risk =>
                    risk.riskNumber || risk.dateRaised || risk.riskItem
                );
                
                validRisks.forEach(risk => {
                    risk.dateRaised = getFormattedDate(risk.dateRaised);
                    risk.reviewDate = getFormattedDate(risk.reviewDate);
                    risk.sourceLastReviewDate = getFormattedDate(risk.sourceLastReviewDate);
                    risk.sourceDueDate = getFormattedDate(risk.sourceDueDate);
                });
                
                await bulkPutRisksDB(validRisks);
                await loadRisks(); 

                alert(`Data loaded successfully from JSON! Total risks: ${risks.length}`);
            } catch (error) {
                alert('Error processing JSON file. Please ensure it is correctly formatted. Details: ' + error.message);
                console.error('[JSON] Processing Error:', error);
            }
        }
        
        // NEW FUNCTION: Load default JSON file from a hardcoded location
        async function loadDefaultFile() {
            loadDefaultFileButton.classList.add('loading');
            
            try {
                const currentRiskCount = (await getAllRisksDB()).length;
                
                const confirmationMessage = currentRiskCount > 0 
                    ? 'Loading the default file will REPLACE all current data in the register. Are you sure?'
                    : 'Load the default risk register data?';

                if (!confirm(confirmationMessage)) {
                    loadDefaultFileButton.classList.remove('loading');
                    return;
                }

                console.log(`[DEFAULT LOAD] Fetching file from: ${DEFAULT_RISK_FILE_PATH}`);
                const response = await fetch(DEFAULT_RISK_FILE_PATH);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}. Make sure the file exists at the path: ${DEFAULT_RISK_FILE_PATH}`);
                }
                
                const jsonText = await response.text();
                
                // Set the persistent filename indicator to "Default System Data"
                localStorage.setItem('lastImportedFile', 'Default System Data');
                
                // Use existing JSON load function
                await loadJson(jsonText); 
                
            } catch (error) {
                alert(`Error loading default file: ${error.message}`);
                console.error('[DEFAULT LOAD CRITICAL] Fetch/Processing Error:', error);
            } finally {
                loadDefaultFileButton.classList.remove('loading');
            }
        }


        function convertToCsv(dataArray) {
            const headerRow = csvHeaders.map(h => `"${h.replace(/"/g, '""')}"`).join(',');
            const rows = dataArray.map(risk => {
                const values = csvHeaders.map(header => {
                    const key = csvHeaderToRiskKeyMap[header];
                    let value = risk[key];
                    if (header === "Age (Days)") {
                        const metrics = calculateDateMetrics(risk.dateRaised, risk.reviewDate);
                        value = metrics.ageDays;
                    } else if (value === undefined || value === null) {
                        value = '';
                    } else if (typeof value === 'string') {
                        value = value.replace(/"/g, '""');
                    }
                    return `"${value}"`;
                });
                return values.join(',');
            });
            return [headerRow, ...rows].join('\n');
        }

        // ==================================================
        // === MODULE 7: CSV Parsing and Load (Fix included) ===
        // ==================================================

        function parseLine(line) {
            const results = [];
            let inQuote = false;
            let currentField = '';
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (i < line.length - 1 && line[i+1] === '"') {
                        currentField += '"';
                        i++;
                    } else {
                        inQuote = !inQuote;
                    }
                } else if (char === ',' && !inQuote) {
                    results.push(currentField);
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            results.push(currentField);
            return results.map(v => v.replace(/^"|"$/g, '').trim());
        }

        function parseCsv(csvText) {
            console.log('[CSV] Starting CSV parsing...');
            const lines = csvText.split(/\r?\n/).filter(line => line.trim() !== '');
            if (lines.length < 1) {
                console.warn('[CSV] No data lines found in CSV.');
                return [];
            }

            const rawHeaders = parseLine(lines[0]);
            const headers = rawHeaders.map(h => h.trim()); 
            
            console.log(`[CSV] Parsed Headers: ${headers.join(' | ')}`);
            
            const parsedRisks = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseLine(lines[i]);
                if (values.length !== headers.length) {
                    console.warn(`[CSV] Skipping line ${i + 1}: Expected ${headers.length} columns, got ${values.length}. Line: ${lines[i].substring(0, 50)}...`);
                    continue;
                }

                const sourceData = {};
                for (let j = 0; j < headers.length; j++) {
                    sourceData[headers[j]] = values[j]; 
                }

                const isClosed = sourceData['Closed Date'] && sourceData['Closed Date'].trim() !== '';

                const probabilityInitial = safeParseInt(sourceData['Likelihood'] || sourceData['Probability (Initial)']);
                const impactInitial = safeParseInt(sourceData['Impact'] || sourceData['Impact (Initial)']);
                const probabilityResidual = safeParseInt(sourceData['Likelihood Total'] || sourceData['Probability (Residual)']);
                const impactResidual = safeParseInt(sourceData['Impact Total'] || sourceData['Impact (Residual)']);

                const scoreInitial = calculateRiskScore(probabilityInitial, impactInitial);
                const ratingInitial = getRiskRating(scoreInitial);
                const scoreResidual = calculateRiskScore(probabilityResidual, impactResidual);
                const ratingResidual = getRiskRating(scoreResidual);

                const risk = {
                    riskNumber: sourceData['Risk Ref.'] || sourceData['Risk Number'] || '',
                    dateRaised: getFormattedDate(sourceData['Date Raised'] || ''),
                    raisedBy: sourceData['Assigned To'] || sourceData['Raised By'] || '',
                    riskItem: sourceData['Risk'] || sourceData['Risk Item'] || '',
                    impactStatement: sourceData['Description of Impact'] || sourceData['Impact Statement'] || '',
                    riskOwner: sourceData['Reviewed By'] || sourceData['Risk Owner'] || '',
                    reviewDate: getFormattedDate(sourceData['Next Review Date'] || sourceData['Review Date'] || ''),
                    
                    actionsText: sourceData['Actions Text (Current)'] || sourceData['Actions'] || sourceData['Notes & Comments'] || '',
                    notesHistory: sourceData['Notes / History'] || '',
                    
                    riskStatus: sourceData['Risk Status'] || (isClosed ? 'Closed' : 'Open'),
                    
                    // Initial Ratings
                    probabilityInitial: probabilityInitial,
                    impactInitial: impactInitial,
                    riskScoreInitial: scoreInitial,
                    riskRatingInitial: ratingInitial,
                    
                    // Residual Ratings
                    probabilityResidual: probabilityResidual,
                    impactResidual: impactResidual,
                    riskScoreResidual: scoreResidual,
                    riskRatingResidual: ratingResidual,

                    controlsMitigations: sourceData['Controls/Mitigations'] || [
                        sourceData['Existing Controls'] || '', 
                        sourceData['Future Controls'] || ''
                    ].filter(c => c).join('; '),

                    sourceDepartment: sourceData['Source Department'] || '',
                    sourceLastReviewDate: getFormattedDate(sourceData['Source Last Review Date'] || ''),
                    sourceDueDate: getFormattedDate(sourceData['Source Due Date'] || ''),
                    
                    riskIssue: sourceData['Risk Issue'] || '', impactedArea: sourceData['Impacted Area'] || '', 
                    riskCategory: sourceData['Risk Category'] || '', relatedLaws: sourceData['Related Laws/Regulations'] || '',
                    nonComplianceImpact: sourceData['Non-Compliance Impact'] || '', outcomeDefinition: sourceData['Outcome Definition'] || '',
                };

                parsedRisks.push(risk);
            }
            console.log(`[CSV] Finished parsing. Total risks parsed: ${parsedRisks.length}`);
            return parsedRisks;
        }

        async function handleCsvLoad(csvText) {
            try {
                let loadedRisks = parseCsv(csvText);
                loadedRisks = await ensureUniqueRiskNumbers(loadedRisks);

                const validRisks = loadedRisks.filter(risk =>
                    risk.riskNumber || risk.dateRaised || risk.riskItem
                );

                if (loadedRisks.length > validRisks.length) {
                    alert(`Warning: ${loadedRisks.length - validRisks.length} rows were skipped due to lack of identifying data (Risk #, Date, or Item).`);
                }

                await bulkPutRisksDB(validRisks);
                await loadRisks(); 

                alert('Data loaded successfully from CSV!');
            } catch (error) {
                alert('Error processing CSV file. Please ensure it is correctly formatted. Details: ' + error.message);
                console.error('[CSV] Processing Error:', error);
            }
        }

        // ================================
        // === MODULE 8: Event Listeners ===
        // ================================

        loadDataButton.addEventListener('click', () => {
            if (!fileInput.files.length) {
                alert('Please select a JSON or CSV file first!');
                return;
            }

            const file = fileInput.files[0];
            const fileName = file.name.toLowerCase();

            if (!fileName.endsWith('.json') && !fileName.endsWith('.csv')) {
                alert('Unsupported file type. Please select a JSON (.json) or CSV (.csv) file.');
                return;
            }

            // Save filename immediately for UI update upon successful load
            const originalFileName = file.name; 

            (async () => {
                loadDataButton.classList.add('loading');
                
                try {
                    const currentRiskCount = (await getAllRisksDB()).length;

                    if (currentRiskCount > 0 && !confirm('Loading a file will REPLACE all current data in the register. Are you sure?')) {
                        loadDataButton.classList.remove('loading'); 
                        return;
                    }

                    const reader = new FileReader();

                    reader.onload = async (e) => {
                        const fileContent = e.target.result;
                        
                        try {
                            if (fileName.endsWith('.json')) {
                                console.log(`[IMPORT] Starting JSON load for file: ${fileName}`);
                                await loadJson(fileContent);
                            } else if (fileName.endsWith('.csv')) {
                                console.log(`[IMPORT] Starting CSV load for file: ${fileName}`);
                                await handleCsvLoad(fileContent);
                            }
                            // Only update the persistent filename on success
                            localStorage.setItem('lastImportedFile', originalFileName);
                            updateLastFileDisplay();
                        } catch (error) {
                            alert('A critical error occurred during file processing. Check the console for details.');
                            console.error('[IMPORT CRITICAL] Processing Error:', error);
                        } finally {
                            loadDataButton.classList.remove('loading');
                        }
                    };

                    reader.onerror = () => {
                        alert('Error reading file. The file may be corrupt or too large.');
                        console.error('[LOAD] File Read Error.');
                        loadDataButton.classList.remove('loading'); 
                    };

                    reader.readAsText(file);
                } catch (error) {
                    console.error('[LOAD BUTTON] Error during initial database check:', error);
                    loadDataButton.classList.remove('loading'); 
                }
            })(); 
        });
        
        // NEW EVENT LISTENER: Default Load Button
        loadDefaultFileButton.addEventListener('click', loadDefaultFile);


        saveJsonButton.addEventListener('click', () => {
            if (risks.length === 0) {
                alert('No data to save! (Array is empty)');
                return;
            }
            const jsonContent = JSON.stringify(risks, null, 2); 
            const filename = `risk_register_${getFormattedDate(new Date())}.json`;
            downloadFile(jsonContent, filename, 'application/json');
            alert('Risk register saved as JSON.');
        });
        
        saveCsvButton.addEventListener('click', () => {
            if (risks.length === 0) {
                alert('No data to save! (Array is empty)');
                return;
            }
            const csvContent = convertToCsv(risks);
            const filename = `risk_register_${getFormattedDate(new Date())}.csv`;
            downloadFile(csvContent, filename, 'text/csv');
            alert('Risk register saved as CSV (Full Format).');
        });

        addNewRiskButton.addEventListener('click', () => {
            window.location.href = 'risk_form.html';
        });

        manageDataButton.addEventListener('click', () => {
            window.location.href = 'data_management.html';
        });

        // ===================================
        // === MODULE 9: Initial Load/Setup ===
        // ===================================
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('[INIT] Document loaded. Starting application using IndexedDB.');
            
            // Check if default filter preference is set
            if (!localStorage.getItem('reviewDateFilter')) {
                localStorage.setItem('reviewDateFilter', 'Overdue');
            }
            
            // Update the file display based on stored value
            updateLastFileDisplay();
            
            await initDB(); 
            const currentRiskCount = (await getAllRisksDB()).length;

            if (currentRiskCount === 0) {
                console.log("[INIT] Database is empty. Prompting user to load default file.");
                if (confirm("The risk register is currently empty. Would you like to load the default dataset?")) {
                    await loadDefaultFile(loadDefaultFileButton);
                } else {
                    await loadRisks(); 
                }
            } else {
                await loadRisks();
            }
        });
    </script>
</body>
</html>